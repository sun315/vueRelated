# 1.20-Q：v-if和v-for哪个优先级高？如果两个同时出现，应该怎么优化得到更好的性能？

* 源码中compiler/codegen/index.js
1. v-for的优先级更高。源码中做if判断的时候，会先判断for 再判断if。
2. 如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能；
3. 要避免出现这种情况，则在外层嵌套templete，在这一层进行v-if判断，然后在内部进行v-for循环。

# 1.21-Q：Vue组件data选项为什么必须是个函数而Vue的根实例则没有此限制？

* 源码中src/core/instance/state.js-initData()

* vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的（源码中会判断data是否是function，是的话会将此function作为参数执行，否则会直接将定义的data对象赋值给data）；在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。（类似一根雪糕，不能多人舔，会造成污染）而在vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。

# 1.22-Q：vue中key的作用和工作原理？

* 源码中src/core/vdom/patch.js-updateChildren()
1. key的作用主要是为了高效的更新虚拟dom，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素（若不加key，会认为是相同的节点，一直更新覆盖），使得整个patch过程更加高效，减少dom操作量，提高性能。 （算法中会有猜测首尾元素的相似性，会很高效，避免大量循环）
2. 另外，若不设置key，还可能在列表更新时引发一些隐蔽的bug（比如，该更新的不更新，不该更新的更新了……）
3. vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。         

# 1.23-Q:怎么理解vue中的diff算法？

* 源码分析1：必要性，lifecycle.js-mountComponent()
* 源码分析2：执行方式，patch.js-patchVnode()
* 源码分析3：高效性，patch.js-updateChildren()

1. diff算法是虚拟dom技术的必然产物：通过新旧虚拟dom作对比（即diff），将变化的地方更新在真实dom上；另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)。
2. vue 2.x中为了降低watcher粒度，每个组件只有一个watcher与之对应，只有引入diff才能精确找到发生变化的地方。
3. vue中diff执行的时刻是组件实例执行其更新函数时，它会对比上一次渲染结果oldVnode和新的渲染结果newVnode，此过程称为patch。
4. diff过程整体遵循深度优先、同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；借助key通常可以非常精确找到相同节点，因此整个patch过程非常高效。

# 1.24-Q:谈一谈对vue组件化的理解？

* 比较大面的问题，可以从组件化定义、优点、使用场景和注意事项等方面展开陈述，同时要强调vue中组件化的一些特点。

* 源码分析1：组件定义，src/core/global-api\assets.js
* 源码分析2：组件化优点，lifecycle.js-mountComponent() 组件、watcher、渲染函数和更新函数之间的关系
* 源码分析3：组件化实现
    * 构造函数，src/core/global-api\extend.js
    * 实例化及挂载，src/core/vdom/patch.js-createElm()

1. 组件是独立和可复用的代码组织单元。组件系统是vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；
2. 组件化开发能大幅提高应用开发效率、测试性、复用性等；
3. 组件使用按分类有：页面组件、业务组件、通用组件；
4. vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于VueComponent，扩展Vue；
5. vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；
6. 合理的划分组件，有助于提升应用性能；
7. 组件应该是高内聚、低耦合的；
8. 遵循单向数据流的原则。

# 1.25-Q：谈一谈对vue的设计原则的理解？

* 在vue官网上写着大大的定义和特点：
    * 渐进式javascript框架
    * 易用、灵活和高效

---    

* 渐进式javascript框架：
    * 与其它大型框架不同的是，vue被设计为可以自底向上逐层应用。vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，vue也完全能够为复杂的单页应用提供驱动。

* 易用性
    * vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。

* 灵活性
    * 渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。

* 高效性
    * 超快的虚拟dom和diff算法使我们的应用拥有最佳的性能表现。
    * 追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。

# 1.26-Q：vue为什么要求组件模板只能有一个根元素？

1. new Vue({el:'#app'})
    * Vue并不知道哪一个才是我们的入口，如果同时设置了多个入口，那么vue就不知道哪一个才是这个“类”。
2. 单文件组件中，templete下的元素div。其实就是“树”状数据结构中的“根”。
    * templete这个标签，有3个特性：
        1. 隐藏性：该标签不会显示在页面的任何地方，即便里面有多少内容，它永远都是隐藏的状态，设置了display:none；
        2. 任意性：该标签可以写在任何地方，甚至是head、body、script标签内；
        3. 无效性: 该标签里的任何HTML内容都是无效的，不会起任何作用；只能innerHTML来获取到里面的内容。
    * 一个vue单文件组件就是一个vue实例，如果templete下有多个div那么如何指定vue实例的根入口呢？为了让组件可以正常生成一个vue实例，这个div会自然的处理成程序的入口，通过这个根节点，来递归遍历整个vue树下的所有节点，并处理为vdom，最后再渲染成真正的HTML，插入在正确的位置。
3. diff算法要求的，源码中，patch.js里的patchVnode().
    * 会先比较根节点相同的情况下，才会继续向下比较相同节点等。


# 1.27-Q：谈谈对MVC、MVP和MVVM的理解？

# 1.28-Q：谈谈对vue组件之间通信的理解？

# 1.29-Q：你了解哪些vue性能优化方法？

# 1.30-Q：vue3有哪些新特性？它们会带来什么影响？

# 1.31-Q：vue如果想扩展某个现有的组件时，应该怎么做？

# 2.1-Q：watch和computed的区别以及怎么选用？

# 2.2-Q：谈谈对vue生命周期的理解？